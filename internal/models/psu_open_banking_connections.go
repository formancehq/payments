package models

import (
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const (
	NoRedirectQueryParamID = "noRedirect"

	ObjectConnectionIDMetadataKey = "object_connection_id"
	ObjectPSUIDMetadataKey        = "object_psu_id"
)

type PSUOpenBankingConnectionAttemptStatus string

const (
	PSUOpenBankingConnectionAttemptStatusPending   PSUOpenBankingConnectionAttemptStatus = "pending"
	PSUOpenBankingConnectionAttemptStatusCompleted PSUOpenBankingConnectionAttemptStatus = "completed"
	PSUOpenBankingConnectionAttemptStatusExited    PSUOpenBankingConnectionAttemptStatus = "exited"
)

// When a user tries to create a connection via an link, we will create an attempt
// in order to save some crucial information.
type PSUOpenBankingConnectionAttempt struct {
	// ID of the attempt
	ID uuid.UUID `json:"id"`
	// ID of the psu
	PsuID uuid.UUID `json:"psuID"`
	// Related connector ID
	ConnectorID ConnectorID `json:"connectorID"`
	// Creation date of the attempt
	CreatedAt time.Time `json:"createdAt"`
	// Status of the attempt
	Status PSUOpenBankingConnectionAttemptStatus `json:"status"`
	// State given to the url in order to be able to verify that the callback
	// is valid.
	State CallbackState `json:"state"`
	// Client redirect URL, given by the user
	ClientRedirectURL *string `json:"clientRedirectURL"`

	// Optional
	// Temporary token generated by the provider in order to create an
	// url.
	TemporaryToken *Token `json:"temporaryToken"`
	// Error message in case of failure
	Error *string `json:"error"`
}

func (a PSUOpenBankingConnectionAttempt) MarshalJSON() ([]byte, error) {
	return json.Marshal(&struct {
		ID                uuid.UUID     `json:"id"`
		PsuID             uuid.UUID     `json:"psuID"`
		ConnectorID       string        `json:"connectorID"`
		CreatedAt         time.Time     `json:"createdAt"`
		Status            string        `json:"status"`
		State             CallbackState `json:"state"`
		ClientRedirectURL *string       `json:"clientRedirectURL,omitempty"`
		TemporaryToken    *Token        `json:"temporaryToken,omitempty"`
		Error             *string       `json:"error,omitempty"`
	}{
		ID:                a.ID,
		PsuID:             a.PsuID,
		ConnectorID:       a.ConnectorID.String(),
		CreatedAt:         a.CreatedAt,
		Status:            string(a.Status),
		State:             a.State,
		ClientRedirectURL: a.ClientRedirectURL,
		TemporaryToken:    a.TemporaryToken,
		Error:             a.Error,
	})
}

func (a *PSUOpenBankingConnectionAttempt) UnmarshalJSON(data []byte) error {
	var aux struct {
		ID                uuid.UUID     `json:"id"`
		PsuID             uuid.UUID     `json:"psuID"`
		ConnectorID       string        `json:"connectorID"`
		CreatedAt         time.Time     `json:"createdAt"`
		Status            string        `json:"status"`
		State             CallbackState `json:"state"`
		ClientRedirectURL *string       `json:"clientRedirectURL,omitempty"`
		TemporaryToken    *Token        `json:"temporaryToken,omitempty"`
		Error             *string       `json:"error,omitempty"`
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	connectorID, err := ConnectorIDFromString(aux.ConnectorID)
	if err != nil {
		return err
	}

	a.ID = aux.ID
	a.PsuID = aux.PsuID
	a.ConnectorID = connectorID
	a.CreatedAt = aux.CreatedAt
	a.Status = PSUOpenBankingConnectionAttemptStatus(aux.Status)
	a.State = aux.State
	a.ClientRedirectURL = aux.ClientRedirectURL
	a.TemporaryToken = aux.TemporaryToken
	a.Error = aux.Error

	return nil
}

// Represents a psu forwarded to an open banking provider
type OpenBankingProviderPSU struct {
	// ID of the psu
	PsuID uuid.UUID `json:"psuID"`
	// ID of the connector
	ConnectorID ConnectorID `json:"connectorID"`

	// Optional
	// AccessToken is optional for some providers, like Powens, where we
	// have a notion of connection, but we only have one token for all of them.
	AccessToken *Token `json:"authToken"`
	// ID of the user on the provider
	PSPUserID *string `json:"pspUserID,omitempty"`
	// per provider additional information
	Metadata map[string]string `json:"metadata"`
}

type ConnectionStatus string

const (
	ConnectionStatusActive ConnectionStatus = "ACTIVE"
	ConnectionStatusError  ConnectionStatus = "ERROR"
)

type PSPPsuOpenBankingConnection struct {
	// ID of the connection, given by the aggregator
	ConnectionID string `json:"connectionID"`
	// Creation date of the connection
	CreatedAt time.Time `json:"createdAt"`

	// Optional
	// AccessToken is optional for some aggregators, like Powens, where we
	// have a notion of connection, but we only have one token for all of them.
	AccessToken *Token `json:"accessToken"`
	// Additional information about the connection depending on the connector
	Metadata map[string]string `json:"metadata"`
}

type PSUOpenBankingConnection struct {
	// ID of the connection, given by the aggregator
	ConnectionID string `json:"connectionID"`
	// Connector ID
	ConnectorID ConnectorID `json:"connectorID"`
	// Creation date of the connection
	CreatedAt time.Time `json:"createdAt"`
	// Date of the last update of the connection's data
	DataUpdatedAt time.Time `json:"dataUpdatedAt"`
	// Status of the connection
	Status ConnectionStatus `json:"status"`

	// Optional
	// AccessToken is optional for some aggregator, like Powens, where we
	// have a notion of connection, but we only have one token for all of them.
	AccessToken *Token `json:"accessToken"`
	// Error message in case of failure
	Error *string `json:"error"`
	// Additional information about the connection depending on the connector
	Metadata map[string]string `json:"metadata"`
}

func (psu PSUOpenBankingConnection) MarshalJSON() ([]byte, error) {
	return json.Marshal(&struct {
		ConnectionID string            `json:"connectionID"`
		ConnectorID  string            `json:"connectorID"`
		CreatedAt    time.Time         `json:"createdAt"`
		Status       string            `json:"status"`
		AccessToken  *Token            `json:"accessToken"`
		Metadata     map[string]string `json:"metadata"`
		Error        *string           `json:"error,omitempty"`
	}{
		ConnectionID: psu.ConnectionID,
		ConnectorID:  psu.ConnectorID.String(),
		CreatedAt:    psu.CreatedAt,
		Status:       string(psu.Status),
		AccessToken:  psu.AccessToken,
		Metadata:     psu.Metadata,
		Error:        psu.Error,
	})
}

func (psu *PSUOpenBankingConnection) UnmarshalJSON(data []byte) error {
	var aux struct {
		ConnectionID string            `json:"connectionID"`
		ConnectorID  string            `json:"connectorID"`
		CreatedAt    time.Time         `json:"createdAt"`
		Status       string            `json:"status"`
		AccessToken  *Token            `json:"accessToken"`
		Metadata     map[string]string `json:"metadata"`
		Error        *string           `json:"error,omitempty"`
	}

	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}

	connectorID, err := ConnectorIDFromString(aux.ConnectorID)
	if err != nil {
		return err
	}

	psu.ConnectionID = aux.ConnectionID
	psu.ConnectorID = connectorID
	psu.CreatedAt = aux.CreatedAt
	psu.Status = ConnectionStatus(aux.Status)
	psu.AccessToken = aux.AccessToken
	psu.Metadata = aux.Metadata
	psu.Error = aux.Error

	return nil
}

func ToPSPPsuOpenBankingConnection(from PSUOpenBankingConnection) PSPPsuOpenBankingConnection {
	return PSPPsuOpenBankingConnection{
		ConnectionID: from.ConnectionID,
		CreatedAt:    from.CreatedAt,
		AccessToken:  from.AccessToken,
		Metadata:     from.Metadata,
	}
}

func FromPSPPsuOpenBankingConnection(from PSPPsuOpenBankingConnection, connectorID ConnectorID) PSUOpenBankingConnection {
	return PSUOpenBankingConnection{
		ConnectionID:  from.ConnectionID,
		ConnectorID:   connectorID,
		CreatedAt:     from.CreatedAt,
		DataUpdatedAt: time.Time{},
		AccessToken:   from.AccessToken,
		Metadata:      from.Metadata,
	}
}
